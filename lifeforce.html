<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>LifeForge - Developmental Biology Simulator</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js/dist/chart.umd.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background: linear-gradient(135deg, #0a0e27 0%, #1a1a2e 100%);
            color: #e0f0ff;
            min-height: 100vh;
            overflow-x: hidden;
            touch-action: pan-y;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 10px;
        }

        @media (min-width: 768px) {
            .container {
                padding: 20px;
            }
        }

        header {
            text-align: center;
            padding: 20px 0;
            margin-bottom: 20px;
            border-bottom: 2px solid #7fdbca;
        }

        @media (min-width: 768px) {
            header {
                padding: 30px 0;
                margin-bottom: 30px;
            }
        }

        h1 {
            font-size: 2rem;
            margin-bottom: 10px;
            background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        @media (min-width: 768px) {
            h1 {
                font-size: 3rem;
            }
        }

        .tagline {
            font-size: 1rem;
            color: #a0c8ff;
            font-style: italic;
            margin-bottom: 8px;
        }

        @media (min-width: 768px) {
            .tagline {
                font-size: 1.2rem;
                margin-bottom: 10px;
            }
        }

        .subtitle {
            font-size: 0.9rem;
            color: #7fdbca;
        }

        @media (min-width: 768px) {
            .subtitle {
                font-size: 1rem;
            }
        }

        .main-layout {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 20px;
        }

        @media (min-width: 1024px) {
            .main-layout {
                display: grid;
                grid-template-columns: 300px 1fr;
                gap: 20px;
                margin-bottom: 30px;
            }
        }

        .control-panel {
            background: rgba(16, 32, 54, 0.7);
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(79, 172, 254, 0.2);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            height: fit-content;
        }

        @media (min-width: 768px) {
            .control-panel {
                padding: 20px;
            }
        }

        .panel-title {
            font-size: 1.1rem;
            margin-bottom: 15px;
            color: #4facfe;
            border-bottom: 1px solid rgba(79, 172, 254, 0.3);
            padding-bottom: 8px;
        }

        @media (min-width: 768px) {
            .panel-title {
                font-size: 1.3rem;
                margin-bottom: 20px;
                padding-bottom: 10px;
            }
        }

        .control-group {
            margin-bottom: 15px;
        }

        @media (min-width: 768px) {
            .control-group {
                margin-bottom: 20px;
            }
        }

        .control-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #a0c8ff;
            font-size: 0.85rem;
        }

        @media (min-width: 768px) {
            .control-label {
                font-size: 0.9rem;
            }
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .slider {
            flex: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            border-radius: 5px;
            background: rgba(79, 172, 254, 0.2);
            outline: none;
            touch-action: none;
        }

        @media (min-width: 768px) {
            .slider {
                height: 6px;
            }
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #4facfe;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(79, 172, 254, 0.7);
        }

        @media (min-width: 768px) {
            .slider::-webkit-slider-thumb {
                width: 18px;
                height: 18px;
            }
        }

        .slider-value {
            min-width: 45px;
            text-align: center;
            font-weight: bold;
            color: #4facfe;
            font-size: 0.9rem;
        }

        button {
            width: 100%;
            padding: 14px 12px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%);
            color: #0a0e27;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 10px;
            font-size: 0.9rem;
            touch-action: manipulation;
            -webkit-user-select: none;
            user-select: none;
        }

        @media (min-width: 768px) {
            button {
                padding: 12px;
                font-size: 0.95rem;
            }
        }

        button:active {
            transform: scale(0.98);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(79, 172, 254, 0.4);
        }

        @media (hover: none) {
            button:hover {
                transform: none;
            }
        }

        button.secondary {
            background: rgba(79, 172, 254, 0.2);
            color: #4facfe;
        }

        button.danger {
            background: linear-gradient(90deg, #ff6b6b 0%, #ee5a6f 100%);
            color: white;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .viz-container {
            background: rgba(16, 32, 54, 0.7);
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(79, 172, 254, 0.2);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
        }

        @media (min-width: 768px) {
            .viz-container {
                padding: 20px;
            }
        }

        .canvas-wrapper {
            position: relative;
            background: #0a0e1a;
            border: 1px solid #334155;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 15px;
            touch-action: none;
        }

        canvas {
            display: block;
            width: 100%;
            height: 400px;
            touch-action: none;
        }

        @media (min-width: 768px) {
            canvas {
                height: 600px;
            }
        }

        .stats-bar {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        @media (min-width: 640px) {
            .stats-bar {
                grid-template-columns: repeat(4, 1fr);
                gap: 15px;
                margin-top: 20px;
            }
        }

        .stat-card {
            background: rgba(10, 22, 40, 0.8);
            padding: 12px;
            border-radius: 8px;
            border-left: 3px solid #4facfe;
            text-align: center;
        }

        @media (min-width: 768px) {
            .stat-card {
                padding: 15px;
            }
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #4facfe;
            margin-bottom: 5px;
        }

        @media (min-width: 768px) {
            .stat-value {
                font-size: 1.8rem;
            }
        }

        .stat-label {
            font-size: 0.75rem;
            color: #a0c8ff;
        }

        @media (min-width: 768px) {
            .stat-label {
                font-size: 0.85rem;
            }
        }

        .cell-legend {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-top: 15px;
        }

        @media (min-width: 640px) {
            .cell-legend {
                grid-template-columns: repeat(3, 1fr);
                gap: 10px;
                margin-top: 20px;
            }
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background: rgba(10, 22, 40, 0.5);
            border-radius: 6px;
            position: relative;
        }

        .legend-item.locked {
            opacity: 0.4;
        }

        .legend-item .lock-icon {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.8rem;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            box-shadow: 0 0 8px currentColor;
            flex-shrink: 0;
        }

        @media (min-width: 768px) {
            .legend-color {
                width: 20px;
                height: 20px;
                box-shadow: 0 0 10px currentColor;
            }
        }

        .legend-label {
            font-size: 0.75rem;
            color: #cbd5e1;
        }

        @media (min-width: 768px) {
            .legend-label {
                font-size: 0.85rem;
            }
        }

        .cell-info-panel {
            background: rgba(10, 22, 40, 0.9);
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
            border: 1px solid #4facfe;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .cell-info-panel h3 {
            font-size: 1.1rem;
            color: #4facfe;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(79, 172, 254, 0.3);
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            font-size: 0.85rem;
        }

        .info-item {
            display: flex;
            flex-direction: column;
        }

        .info-label {
            color: #a0c8ff;
            font-size: 0.75rem;
        }

        .info-value {
            font-weight: bold;
        }

        .phase-indicator {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(16, 32, 54, 0.95);
            padding: 10px 15px;
            border-radius: 8px;
            border: 2px solid #4facfe;
            font-size: 0.9rem;
            font-weight: bold;
            color: #4facfe;
            z-index: 1000;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.4);
        }

        @media (min-width: 768px) {
            .phase-indicator {
                top: 20px;
                right: 20px;
                padding: 15px 25px;
                font-size: 1.1rem;
            }
        }

        .view-mode-selector {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 6px;
            margin-bottom: 12px;
        }

        @media (min-width: 768px) {
            .view-mode-selector {
                gap: 8px;
                margin-bottom: 15px;
            }
        }

        .view-btn {
            padding: 10px 8px;
            margin: 0;
            font-size: 0.8rem;
        }

        @media (min-width: 768px) {
            .view-btn {
                padding: 8px;
                font-size: 0.85rem;
            }
        }

        .view-btn.active {
            background: linear-gradient(90deg, #00f2fe 0%, #4facfe 100%);
            color: #0a0e27;
        }

        footer {
            text-align: center;
            padding: 15px;
            color: #64748b;
            border-top: 1px solid rgba(79, 172, 254, 0.2);
            margin-top: 20px;
            font-size: 0.8rem;
        }

        @media (min-width: 768px) {
            footer {
                padding: 20px;
                margin-top: 30px;
                font-size: 0.85rem;
            }
        }

        .tutorial-start-btn {
            margin-top: 10px;
            width: auto;
            padding: 8px 15px;
        }

        .info-panel {
            background: rgba(16, 32, 54, 0.7);
            border-radius: 15px;
            padding: 15px;
            margin-bottom: 15px;
            border: 1px solid rgba(79, 172, 254, 0.2);
        }

        @media (min-width: 768px) {
            .info-panel {
                padding: 20px;
                margin-bottom: 20px;
            }
        }

        .info-text {
            color: #a0c8ff;
            line-height: 1.6;
            font-size: 0.85rem;
        }

        @media (min-width: 768px) {
            .info-text {
                font-size: 0.95rem;
            }
        }

        @media (hover: none) and (pointer: coarse) {
            button {
                min-height: 44px;
            }

            .slider::-webkit-slider-thumb {
                width: 28px;
                height: 28px;
            }

            .view-btn {
                min-height: 44px;
            }
        }

        .canvas-wrapper::-webkit-scrollbar {
            display: none;
        }

        .canvas-wrapper {
            -ms-overflow-style: none;
        }

        .clear-selection-btn {
            display: none !important;
        }

        .game-hud {
            position: fixed;
            top: 60px;
            right: 20px;
            background: rgba(16, 32, 54, 0.95);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #4facfe;
            font-size: 0.9rem;
            color: #e0f0ff;
            z-index: 999;
        }

        .hud-item {
            margin-bottom: 8px;
        }

        .progress-bar {
            height: 8px;
            background: rgba(79, 172, 254, 0.2);
            border-radius: 4px;
            overflow: hidden;
        }

        /* Tutorial Overlay */
        .tutorial-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .tutorial-box {
            background: linear-gradient(135deg, #1a2332 0%, #2a3a4f 100%);
            border-radius: 15px;
            padding: 30px;
            max-width: 600px;
            border: 2px solid #4facfe;
            box-shadow: 0 10px 50px rgba(79, 172, 254, 0.3);
            position: relative;
        }

        .tutorial-box h2 {
            color: #4facfe;
            margin-bottom: 20px;
            font-size: 1.8rem;
        }

        .tutorial-box p {
            color: #a0c8ff;
            line-height: 1.6;
            margin-bottom: 20px;
        }

        .tutorial-highlight {
            position: absolute;
            border: 3px solid #4facfe;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(79, 172, 254, 0.6);
            pointer-events: none;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 20px rgba(79, 172, 254, 0.6); }
            50% { box-shadow: 0 0 40px rgba(79, 172, 254, 1); }
        }

        .tutorial-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .tutorial-buttons button {
            margin: 0;
        }

        /* Notification Banner */
        .notification-banner {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(16, 32, 54, 0.98);
            padding: 20px 40px;
            border-radius: 10px;
            border: 2px solid #4facfe;
            font-size: 1.2rem;
            font-weight: bold;
            color: #4facfe;
            z-index: 1500;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            animation: slideIn 0.5s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translate(-50%, -100%);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%);
            }
        }

        .notification-banner.warning {
            border-color: #ff6b6b;
            color: #ff6b6b;
        }

        .notification-banner.success {
            border-color: #10b981;
            color: #10b981;
        }

        /* Achievement Popup */
        .achievement-popup {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: linear-gradient(135deg, #1a2332 0%, #2a3a4f 100%);
            padding: 15px 20px;
            border-radius: 10px;
            border: 2px solid #f59e0b;
            box-shadow: 0 5px 30px rgba(245, 158, 11, 0.4);
            z-index: 1500;
            animation: achievementSlide 0.5s ease-out;
            max-width: 300px;
        }

        @keyframes achievementSlide {
            from {
                opacity: 0;
                transform: translateX(400px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .achievement-popup h3 {
            color: #f59e0b;
            margin-bottom: 5px;
            font-size: 1rem;
        }

        .achievement-popup p {
            color: #a0c8ff;
            font-size: 0.9rem;
        }

        /* Modal */
        .modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(16, 32, 54, 0.98);
            padding: 30px;
            border-radius: 15px;
            border: 2px solid #4facfe;
            text-align: center;
            z-index: 2000;
            color: #e0f0ff;
            max-width: 500px;
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.6);
        }

        .modal h2 {
            color: #4facfe;
            margin-bottom: 15px;
        }

        .modal button {
            margin: 5px;
            width: auto;
            padding: 10px 20px;
        }

        .challenge-panel {
            background: rgba(10, 22, 40, 0.8);
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
            border: 1px solid #f59e0b;
        }

        .challenge-panel h3 {
            color: #f59e0b;
            margin-bottom: 10px;
            font-size: 1rem;
        }

        .challenge-item {
            background: rgba(16, 32, 54, 0.6);
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .challenge-item.completed {
            opacity: 0.6;
            text-decoration: line-through;
        }

        .challenge-reward {
            color: #10b981;
            font-size: 0.85rem;
        }

        /* Screen effects */
        @keyframes screenShake {
            0%, 100% { transform: translate(0, 0); }
            10%, 30%, 50%, 70%, 90% { transform: translate(-2px, 2px); }
            20%, 40%, 60%, 80% { transform: translate(2px, -2px); }
        }

        .shake {
            animation: screenShake 0.5s;
        }

        @keyframes screenFlash {
            0%, 100% { background-color: transparent; }
            50% { background-color: rgba(239, 68, 68, 0.3); }
        }

        .flash {
            animation: screenFlash 0.3s;
        }
    </style>
</head>
<body>
    <div class="phase-indicator" id="phaseIndicator">
        Development: READY
    </div>

    <div class="container">
        <header>
            <h1>üß¨ LifeForge</h1>
            <div class="tagline">Watch life emerge from a single cell</div>
            <div class="subtitle">From DNA to organism through developmental biology</div>
        </header>
        <div class="info-panel">
            <div class="info-text">
                <strong>LifeForge simulates how a single cell becomes a complex organism.</strong> 
                Watch cells divide, differentiate into specialized types, and self-organize into patterns through chemical signals. 
                Complete challenges, unlock new cell types, and defend against predators!
                <button id="tutorialBtn" class="tutorial-start-btn">üìö Start Tutorial</button>
            </div>
        </div>

        <div class="main-layout">
            <div class="control-panel">
                <h2 class="panel-title">Development Controls</h2>

                    <button id="clearSelectionBtn" class="secondary clear-selection-btn">‚ùå Clear Selection</button>
                    <button id="startBtn" class="primary">üß¨ Start Development</button>
                    <button id="pauseBtn" class="secondary">‚è∏ Pause</button>
                    <button id="resetViewBtn" class="secondary" title="Reset Pan & Zoom">üîç Reset View</button>
                    <button id="clearSelectionBtn" class="secondary clear-selection-btn">‚ùå Clear Selection</button>
                    <button id="resetBtn" class="secondary">üîÑ Reset to Single Cell</button>
                </div>

                <div class="control-group">
                    <label class="control-label">Development Speed</label>
                    <div class="slider-container">
                        <input type="range" class="slider" id="speedSlider" min="1" max="10" value="3" step="1" title="Development Speed">
                        <span class="slider-value" id="speedValue">3x</span>
                    </div>
                </div>

                <div class="control-group">
                    <label class="control-label">Mutation Rate</label>
                    <div class="slider-container">
                        <input type="range" class="slider" id="mutationSlider" min="0" max="20" value="2" step="1" title="Mutation Rate">
                        <span class="slider-value" id="mutationValue">2%</span>
                    </div>
                </div>

                <div class="control-group">
                    <label class="control-label">Cell Division Rate</label>
                    <div class="slider-container">
                        <input type="range" class="slider" id="divisionSlider" min="1" max="10" value="5" step="1" title="Cell Division Rate">
                        <span class="slider-value" id="divisionValue">5</span>
                    </div>
                </div>

                <div class="control-group">
                    <label class="control-label">Cell Adhesion</label>
                    <div class="slider-container">
                        <input type="range" class="slider" id="adhesionSlider" min="0" max="100" value="10" step="1" title="Cell Adhesion Strength">
                        <span class="slider-value" id="adhesionValue">10%</span>
                    </div>
                </div>

                <h2 class="panel-title" style="margin-top: 30px;">Environmental Factors</h2>

                <div class="control-group">
                    <label class="control-label">Temperature</label>
                    <div class="slider-container">
                        <input type="range" class="slider" id="temperatureSlider" min="0" max="100" value="50" step="1" title="Environment Temperature">
                        <span class="slider-value" id="temperatureValue">50¬∞C</span>
                    </div>
                </div>

                <div class="control-group">
                    <label class="control-label">Toxicity</label>
                    <div class="slider-container">
                        <input type="range" class="slider" id="toxicitySlider" min="0" max="100" value="0" step="1" title="Environment Toxicity">
                        <span class="slider-value" id="toxicityValue">0%</span>
                    </div>
                </div>

                <div class="control-group">
                    <label class="control-label">Nutrient Level</label>
                    <div class="slider-container">
                        <input type="range" class="slider" id="nutrientSlider" min="10" max="200" value="100" step="1" title="Nutrient Availability">
                        <span class="slider-value" id="nutrientValue">100%</span>
                    </div>
                </div>

                <h2 class="panel-title" style="margin-top: 30px;">Interventions</h2>

                <button id="mutateBtn" class="danger">‚ö° Cause Mutation</button>
                <button id="addCellsBtn">‚ûï Add Stem Cells</button>
                <button id="killCellsBtn" class="danger">üí• Kill Random Cells</button>
                <button id="spawnPredatorBtn" class="danger">ü¶† Spawn Predator</button>

                <h2 class="panel-title" style="margin-top: 30px;">Export</h2>

                <button id="exportImageBtn">üì∏ Export as Image</button>

                <h2 class="panel-title" style="margin-top: 30px;">Population Dynamics</h2>
                <div class="chart-container">
                    <canvas id="populationChart"></canvas>
                </div>
            </div>

            <div class="viz-container">
                <div class="view-mode-selector">
                    <button class="view-btn active" data-view="cells">Cell Types</button>
                    <button class="view-btn" data-view="chemicals">Chemicals</button>
                    <button class="view-btn" data-view="energy">Energy</button>
                    <button class="view-btn" data-view="genes">Gene Activity</button>
                </div>

                <div class="canvas-wrapper" id="canvasWrapper">
                    <canvas id="lifeCanvas"></canvas>
                </div>

                <div class="stats-bar">
                    <div class="stat-card">
                        <div class="stat-value" id="cellCount">1</div>
                        <div class="stat-label">Total Cells</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="stemCells">1</div>
                        <div class="stat-label">Stem Cells</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="divisions">0</div>
                        <div class="stat-label">Cell Divisions</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="generation">0</div>
                        <div class="stat-label">Generation</div>
                    </div>
                </div>

                <div class="cell-legend">
                    <div class="legend-item" data-celltype="stem">
                        <div class="legend-color" style="background-color: #a855f7; color: #a855f7;"></div>
                        <span class="legend-label">Stem</span>
                    </div>
                    <div class="legend-item" data-celltype="muscle">
                        <div class="legend-color" style="background-color: #ef4444; color: #ef4444;"></div>
                        <span class="legend-label">Muscle</span>
                    </div>
                    <div class="legend-item" data-celltype="neural">
                        <div class="legend-color" style="background-color: #3b82f6; color: #3b82f6;"></div>
                        <span class="legend-label">Neural</span>
                    </div>
                    <div class="legend-item" data-celltype="digestive">
                        <div class="legend-color" style="background-color: #10b981; color: #10b981;"></div>
                        <span class="legend-label">Digestive</span>
                    </div>
                    <div class="legend-item locked" data-celltype="structural">
                        <div class="legend-color" style="background-color: #f59e0b; color: #f59e0b;"></div>
                        <span class="legend-label">Structural</span>
                        <span class="lock-icon">üîí</span>
                    </div>
                    <div class="legend-item locked" data-celltype="reproductive">
                        <div class="legend-color" style="background-color: #ec4899; color: #ec4899;"></div>
                        <span class="legend-label">Reproductive</span>
                        <span class="lock-icon">üîí</span>
                    </div>
                </div>

                <div class="challenge-panel">
                    <h3>üéØ Active Challenges</h3>
                    <div id="challengeList"></div>
                </div>

                <div class="cell-info-panel" id="cellInfoPanel" style="display: none;">
                    <h3>Selected Cell Info</h3>
                    <div class="info-grid">
                        <div class="info-item">
                            <span class="info-label">Type</span>
                            <span class="info-value" id="info-type"></span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">Position (X, Y)</span>
                            <span class="info-value" id="info-pos"></span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">Age</span>
                            <span class="info-value" id="info-age"></span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">Generation</span>
                            <span class="info-value" id="info-gen"></span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">Energy</span>
                            <span class="info-value" id="info-energy"></span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">Status</span>
                            <span class="info-value" id="info-status"></span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <footer>
            LifeForge - Where information becomes form
            <br>Simulating the bridge between genotype and phenotype
        </footer>
    </div>

    <script>
        // ============================================
        // LIFEFORGE - ENHANCED EDITION
        // ============================================

        const canvas = document.getElementById('lifeCanvas');
        const ctx = canvas.getContext('2d');

        // Configuration
        const Config = {
            cellSize: window.innerWidth < 640 ? 6 : 8,
            gridWidth: 0,
            gridHeight: 0,
            speed: 3,
            mutationRate: 0.02,
            morphogenStrength: 5,
            diffusionRate: 0.1,
            productionRate: 0.2,
            adhesionStrength: 0.1,
            divisionRate: 5,
            developmentMode: 'symmetric'
        };

        // Environmental factors
        const Environment = {
            temperature: 50,
            toxicity: 0,
            nutrientLevel: 1.0
        };

        // Unlock system
        const Unlocks = {
            structural: false,
            reproductive: false,
            predatorResistance: false,
            fasterDivision: false,
            efficientMetabolism: false
        };

        // Set canvas size
        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            if (window.innerWidth < 768) {
                canvas.height = 400;
            } else {
                canvas.height = 600;
            }

            Config.gridWidth = Math.floor(canvas.width / Config.cellSize);
            Config.gridHeight = Math.floor(canvas.height / Config.cellSize);

            spatialGrid = new SpatialGrid(Config.gridWidth, Config.gridHeight);

            if (typeof morphogenField !== 'undefined') {
                morphogenField = new MorphogenField();
            }

            if (typeof cells !== 'undefined' && cells.length > 0) {
                draw();
            }
        }

        // Cell types
        const CellTypes = {
            STEM: { name: 'stem', color: '#a855f7', glow: 'rgba(168, 85, 247, 0.5)', unlocked: true },
            MUSCLE: { name: 'muscle', color: '#ef4444', glow: 'rgba(239, 68, 68, 0.5)', unlocked: true },
            NEURAL: { name: 'neural', color: '#3b82f6', glow: 'rgba(59, 130, 246, 0.5)', unlocked: true },
            DIGESTIVE: { name: 'digestive', color: '#10b981', glow: 'rgba(16, 185, 129, 0.5)', unlocked: true },
            STRUCTURAL: { name: 'structural', color: '#f59e0b', glow: 'rgba(245, 158, 11, 0.5)', unlocked: false },
            REPRODUCTIVE: { name: 'reproductive', color: '#ec4899', glow: 'rgba(236, 72, 153, 0.5)', unlocked: false },
            PREDATOR: { name: 'predator', color: '#8b0000', glow: 'rgba(139, 0, 0, 0.7)', unlocked: false }
        };

        // Particle system
        class Particle {
            constructor(x, y, color, type = 'burst') {
                this.x = x;
                this.y = y;
                this.color = color;
                this.type = type;
                this.life = 1.0;
                this.maxLife = type === 'chemical' ? 60 : 30;
                this.age = 0;
                
                if (type === 'burst') {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 2 + 1;
                    this.vx = Math.cos(angle) * speed;
                    this.vy = Math.sin(angle) * speed;
                    this.size = Math.random() * 3 + 2;
                } else if (type === 'chemical') {
                    this.vx = (Math.random() - 0.5) * 0.5;
                    this.vy = (Math.random() - 0.5) * 0.5;
                    this.size = Math.random() * 2 + 1;
                } else if (type === 'sparkle') {
                    this.vx = (Math.random() - 0.5) * 0.3;
                    this.vy = -Math.random() * 2;
                    this.size = Math.random() * 4 + 1;
                }
            }

            update() {
                this.age++;
                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.1; // Gravity
                this.life = 1 - (this.age / this.maxLife);
                return this.life > 0;
            }

            draw(ctx) {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        let particles = [];

        function createParticleBurst(x, y, color, count = 8, type = 'burst') {
            for (let i = 0; i < count; i++) {
                particles.push(new Particle(x, y, color, type));
            }
        }

        // Cell class
        class Cell {
            constructor(x, y, type = CellTypes.STEM, generation = 0) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.age = 0;
                this.generation = generation;
                this.energy = 100;
                this.divisionCooldown = 0;
                this.isAlive = true;
                this.readyToDivide = false;
                this.voltage = 0;
                this.fireCooldown = 0;
                this.isFiring = false;
                this.contractCooldown = 0;
                this.isContracting = false;
                this.isPredator = false;
                this.justDifferentiated = false;
            }

            update(morphogenField) {
                this.age++;
                this.divisionCooldown = Math.max(0, this.divisionCooldown - 1);

                // Predator behavior
                if (this.type === CellTypes.PREDATOR) {
                    this.updatePredator();
                    return;
                }

                // Environmental effects
                const tempDifference = Math.abs(Environment.temperature - 50);
                const metabolicCost = 0.1 + (tempDifference / 500);
                this.energy -= metabolicCost;

                if (Math.random() < (Environment.toxicity / 100)) {
                    this.energy -= 5;
                }

                // Energy production
                if (this.type === CellTypes.DIGESTIVE) {
                    const energyProduction = 0.5 * Environment.nutrientLevel;
                    this.energy = Math.min(200, this.energy + energyProduction);
                }

                // Apoptosis
                if (this.energy <= 0) {
                    this.isAlive = false;
                    createParticleBurst(
                        this.x * Config.cellSize + Config.cellSize/2,
                        this.y * Config.cellSize + Config.cellSize/2,
                        this.type.color,
                        6,
                        'burst'
                    );
                    return;
                }

                // Get chemical signals
                const signals = morphogenField.getSignalsAt(this.x, this.y);

                // Differentiation
                if (this.type === CellTypes.STEM && this.age > 10) {
                    this.differentiate(signals);
                }

                // Division readiness
                const divisionBonus = Unlocks.fasterDivision ? 2 : 1;
                if (this.energy > 50 && this.divisionCooldown === 0 && this.age > 5 && 
                    Math.random() < (Config.divisionRate * divisionBonus) / 100) {
                    this.energy -= 40;
                    this.readyToDivide = true;
                    
                    // Division particle effect
                    createParticleBurst(
                        this.x * Config.cellSize + Config.cellSize/2,
                        this.y * Config.cellSize + Config.cellSize/2,
                        '#ffffff',
                        12,
                        'burst'
                    );
                }
            }

            updatePredator() {
                this.energy -= 0.5; // Predators need constant energy
                
                if (this.energy <= 0) {
                    this.isAlive = false;
                    return;
                }

                // Hunt for prey
                if (this.age % 5 === 0) {
                    const nearestPrey = this.findNearestPrey();
                    if (nearestPrey) {
                        this.moveTowards(nearestPrey);
                    }
                }
            }

            findNearestPrey() {
                // --- FIX for Bug 2 (Performance) ---
                // Efficiently find nearest prey using an expanding radius search
                let radius = 1;
                const maxRadius = Math.max(Config.gridWidth, Config.gridHeight);

                while (radius < maxRadius) {
                    // Get neighbors in the current "ring" (using radius)
                    const neighbors = spatialGrid.getNeighbors(this, radius);
                    
                    let closestInRadius = null;
                    let minDist = Infinity;

                    for (const neighbor of neighbors) {
                        if (neighbor.type !== CellTypes.PREDATOR && neighbor.isAlive) {
                            const dist = Math.abs(neighbor.x - this.x) + Math.abs(neighbor.y - this.y);
                            
                            // Only check neighbors at the current radius boundary
                            if (Math.max(Math.abs(neighbor.x - this.x), Math.abs(neighbor.y - this.y)) === radius) {
                                if (dist < minDist) {
                                    minDist = dist;
                                    closestInRadius = neighbor;
                                }
                            }
                        }
                    }

                    if (closestInRadius) {
                        return closestInRadius; // Found the closest prey in this ring
                    }
                    radius++; // Expand search radius
                }
                return null; // No prey found
                // --- End of Bug 2 Fix ---
            }

            moveTowards(target) {
                const dx = Math.sign(target.x - this.x);
                const dy = Math.sign(target.y - this.y);
                
                let newX = this.x;
                let newY = this.y;

                // --- FIX for Bug 1 (Flawed Movement) ---
                // If we need to move, decide which way
                if (dx !== 0 || dy !== 0) {
                    if (dx !== 0 && dy !== 0) {
                        // Diagonal move needed, pick one axis randomly
                        if (Math.random() < 0.5) {
                            newX += dx; // Try horizontal
                        } else {
                            newY += dy; // Try vertical
                        }
                    } else if (dx !== 0) {
                        newX += dx; // Only horizontal move needed
                    } else {
                        newY += dy; // Only vertical move needed
                    }
                } else {
                    return; // Already at target
                }
                // --- End of Bug 1 Fix ---
                
                if (newX >= 0 && newX < Config.gridWidth && newY >= 0 && newY < Config.gridHeight) {
                    // --- FIX for Bug 2 (Performance) ---
                    // const cellAtPos = cells.find(c => c.x === newX && c.y === newY); // Old O(N) check
                    const cellAtPos = spatialGrid.get(newX, newY); // New O(1) check
                    // --- End of Bug 2 Fix ---

                    if (!cellAtPos) {
                        // Spot is empty, move there
                        this.x = newX;
                        this.y = newY;
                    } else if (cellAtPos.type !== CellTypes.PREDATOR) {
                        // Spot has prey, eat it and move there
                        cellAtPos.isAlive = false;
                        this.energy += 50;
                        createParticleBurst(
                            newX * Config.cellSize + Config.cellSize/2,
                            newY * Config.cellSize + Config.cellSize/2,
                            '#ff0000',
                            10,
                            'burst'
                        );
                        this.x = newX;
                        this.y = newY;
                    }
                    // Else: spot is blocked by another predator, do nothing
                }
            }

            differentiate(signals) {
                if (Math.random() < Config.mutationRate) {
                    const availableTypes = Object.values(CellTypes).filter(t => t.unlocked && t !== CellTypes.STEM && t !== CellTypes.PREDATOR);
                    if (availableTypes.length > 0) {
                        this.type = availableTypes[Math.floor(Math.random() * availableTypes.length)];
                        this.justDifferentiated = true;
                        
                        // Differentiation sparkle effect
                        createParticleBurst(
                            this.x * Config.cellSize + Config.cellSize/2,
                            this.y * Config.cellSize + Config.cellSize/2,
                            this.type.color,
                            15,
                            'sparkle'
                        );
                    }
                    return;
                }

                const { signalA, signalB, signalC } = signals;

                if (signalA > 0.5 && signalA > signalB && signalA > signalC) {
                    this.type = CellTypes.NEURAL;
                } else if (signalB > 0.5 && signalB > signalA && signalB > signalC) {
                    this.type = CellTypes.DIGESTIVE;
                } else if (signalC > 0.5 && CellTypes.REPRODUCTIVE.unlocked) {
                    this.type = CellTypes.REPRODUCTIVE;
                } else if (signalA > 0.2 && signalB > 0.2) {
                    this.type = CellTypes.MUSCLE;
                } else if (CellTypes.STRUCTURAL.unlocked) {
                    this.type = CellTypes.STRUCTURAL;
                } else {
                    this.type = CellTypes.MUSCLE;
                }
                
                this.justDifferentiated = true;
                createParticleBurst(
                    this.x * Config.cellSize + Config.cellSize/2,
                    this.y * Config.cellSize + Config.cellSize/2,
                    this.type.color,
                    15,
                    'sparkle'
                );
            }
        }

        // Morphogen field
        class MorphogenField {
            constructor() {
                const size = Config.gridWidth * Config.gridHeight;
                this.signalA = new Float32Array(size);
                this.signalB = new Float32Array(size);
                this.signalC = new Float32Array(size);
                this.initialize();
            }

            initialize() {
                this.signalA.fill(0);
                this.signalB.fill(0);
                this.signalC.fill(0);
            }

            update(cells) {
                cells.forEach(cell => {
                    if (cell.type === CellTypes.PREDATOR) return;
                    
                    const index = cell.y * Config.gridWidth + cell.x;
                    if (cell.type === CellTypes.NEURAL) {
                        this.signalA[index] = Math.min(1.0, this.signalA[index] + Config.productionRate);
                        
                        // Chemical trail particles
                        if (Math.random() < 0.1) {
                            createParticleBurst(
                                cell.x * Config.cellSize + Config.cellSize/2,
                                cell.y * Config.cellSize + Config.cellSize/2,
                                'rgba(79, 172, 254, 0.5)',
                                2,
                                'chemical'
                            );
                        }
                    } else if (cell.type === CellTypes.DIGESTIVE) {
                        this.signalB[index] = Math.min(1.0, this.signalB[index] + Config.productionRate);
                        
                        if (Math.random() < 0.1) {
                            createParticleBurst(
                                cell.x * Config.cellSize + Config.cellSize/2,
                                cell.y * Config.cellSize + Config.cellSize/2,
                                'rgba(16, 185, 129, 0.5)',
                                2,
                                'chemical'
                            );
                        }
                    } else if (cell.type === CellTypes.REPRODUCTIVE) {
                        this.signalC[index] = Math.min(1.0, this.signalC[index] + Config.productionRate);
                    }
                });

                this.diffuse(this.signalA);
                this.diffuse(this.signalB);
                this.diffuse(this.signalC);
            }

            diffuse(grid) {
                const nextGrid = new Float32Array(grid.length);
                const decay = 0.99;

                for (let y = 0; y < Config.gridHeight; y++) {
                    for (let x = 0; x < Config.gridWidth; x++) {
                        const index = y * Config.gridWidth + x;
                        let sum = 0;
                        let count = 0;

                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const nx = x + dx;
                                const ny = y + dy;
                                if (nx >= 0 && nx < Config.gridWidth && ny >= 0 && ny < Config.gridHeight) {
                                    sum += grid[ny * Config.gridWidth + nx];
                                    count++;
                                }
                            }
                        }

                        const average = sum / count;
                        const currentVal = grid[index];
                        nextGrid[index] = (currentVal + (average - currentVal) * Config.diffusionRate) * decay;
                    }
                }
                grid.set(nextGrid);
            }

            getSignalsAt(x, y) {
                const index = y * Config.gridWidth + x;
                return {
                    signalA: this.signalA[index] || 0,
                    signalB: this.signalB[index] || 0,
                    signalC: this.signalC[index] || 0
                };
            }
        }

        // ============================================
        // NEW CLASS: SpatialGrid
        // ============================================
        class SpatialGrid {
            constructor(width, height) {
                this.width = width;
                this.height = height;
                this.grid = new Map();
            }

            _getKey(x, y) {
                return `${x},${y}`;
            }

            clear() {
                this.grid.clear();
            }

            add(cell) {
                const key = this._getKey(cell.x, cell.y);
                this.grid.set(key, cell);
            }

            get(x, y) {
                const key = this._getKey(x, y);
                return this.grid.get(key) || null;
            }

            getNeighbors(cell, radius) {
                const neighbors = [];
                for (let y = cell.y - radius; y <= cell.y + radius; y++) {
                    for (let x = cell.x - radius; x <= cell.x + radius; x++) {
                        if (x === cell.x && y === cell.y) continue;
                        // Ensure we are within grid bounds (optional, but good practice)
                        if (x < 0 || x >= this.width || y < 0 || y >= this.height) continue;
                        
                        const neighbor = this.get(x, y);
                        if (neighbor) {
                            neighbors.push(neighbor);
                        }
                    }
                }
                return neighbors;
            }
        }

        // Challenge system
        const Challenges = [
            {
                id: 'first_division',
                name: 'First Division',
                description: 'Divide into 2 cells',
                check: () => cells.length >= 2,
                reward: 100,
                completed: false
            },
            {
                id: 'ten_cells',
                name: 'Growing Colony',
                description: 'Reach 10 cells',
                check: () => cells.length >= 10,
                reward: 250,
                completed: false
            },
            {
                id: 'first_neural',
                name: 'Brain Power',
                description: 'Create your first neural cell',
                check: () => cells.some(c => c.type === CellTypes.NEURAL),
                reward: 200,
                completed: false
            },
            {
                id: 'diversity',
                name: 'Cell Diversity',
                description: 'Have 3 different cell types',
                check: () => {
                    const types = new Set(cells.map(c => c.type.name));
                    return types.size >= 3;
                },
                reward: 500,
                unlock: () => {
                    CellTypes.STRUCTURAL.unlocked = true;
                    updateLegend();
                    showAchievement('Unlocked: Structural Cells!', 'Build stronger organisms');
                },
                completed: false
            },
            {
                id: 'fifty_cells',
                name: 'Thriving Organism',
                description: 'Reach 50 cells',
                check: () => cells.length >= 50,
                reward: 1000,
                unlock: () => {
                    CellTypes.REPRODUCTIVE.unlocked = true;
                    updateLegend();
                    showAchievement('Unlocked: Reproductive Cells!', 'Create offspring');
                },
                completed: false
            },
            {
                id: 'survive_toxin',
                name: 'Toxin Survivor',
                description: 'Survive 30 seconds with 50% toxicity',
                check: () => {
                    if (Environment.toxicity >= 50) {
                        if (!Challenges[5].startTime) {
                            Challenges[5].startTime = time;
                        }
                        return (time - Challenges[5].startTime) >= 30 * Config.speed;
                    }
                    return false;
                },
                reward: 1500,
                unlock: () => {
                    Unlocks.efficientMetabolism = true;
                    showAchievement('Unlocked: Efficient Metabolism!', 'Cells use 25% less energy');
                },
                completed: false
            },
            {
                id: 'neural_network',
                name: 'Neural Network',
                description: 'Have 20 neural cells connected',
                check: () => cells.filter(c => c.type === CellTypes.NEURAL).length >= 20,
                reward: 2000,
                unlock: () => {
                    Unlocks.fasterDivision = true;
                    showAchievement('Unlocked: Rapid Division!', 'Cells divide 2x faster');
                },
                completed: false
            },
            {
                id: 'predator_defense',
                name: 'Predator Defense',
                description: 'Survive a predator attack',
                check: () => {
                    if (cells.some(c => c.type === CellTypes.PREDATOR)) {
                        if (!Challenges[7].predatorSpawned) {
                            Challenges[7].predatorSpawned = true;
                            Challenges[7].startCellCount = cells.filter(c => c.type !== CellTypes.PREDATOR).length;
                        }
                        // If predator died and we still have cells
                        if (!cells.some(c => c.type === CellTypes.PREDATOR) && cells.length > 0) {
                            return true;
                        }
                    }
                    return false;
                },
                reward: 3000,
                unlock: () => {
                    Unlocks.predatorResistance = true;
                    showAchievement('Unlocked: Predator Resistance!', 'Cells are harder to kill');
                },
                completed: false
            }
        ];

        let score = 0;

        function checkChallenges() {
            Challenges.forEach(challenge => {
                if (!challenge.completed && challenge.check()) {
                    challenge.completed = true;
                    score += challenge.reward;
                    showNotification(`Challenge Complete: ${challenge.name}`, 'success');
                    if (challenge.unlock) {
                        challenge.unlock();
                    }
                    updateChallengeDisplay();
                }
            });
        }

        function updateChallengeDisplay() {
            const list = document.getElementById('challengeList');
            list.innerHTML = '';
            
            Challenges.forEach(challenge => {
                const item = document.createElement('div');
                item.className = 'challenge-item' + (challenge.completed ? ' completed' : '');
                item.innerHTML = `
                    <div>
                        <div>${challenge.completed ? '‚úÖ' : 'üéØ'} ${challenge.name}</div>
                        <div style="font-size: 0.8rem; color: #a0c8ff;">${challenge.description}</div>
                    </div>
                    <div class="challenge-reward">+${challenge.reward}</div>
                `;
                list.appendChild(item);
            });
        }

        // Main simulation state
        let cells = [];
        let morphogenField = new MorphogenField();
        let spatialGrid;
        let running = false;
        let time = 0;
        let totalDivisions = 0;
        let currentPhase = '';
        let viewMode = 'cells';
        let selectedCell = null;
        let transform = {
            scale: window.innerWidth < 768 ? 0.5 : 1,
            offsetX: 0,
            offsetY: 0
        };
        let isPanning = false;
        let lastMousePos = { x: 0, y: 0 };
        let populationHistory = [];
        let populationChart = null;

        // Notification system
        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.className = `notification-banner ${type}`;
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.opacity = '0';
                setTimeout(() => notification.remove(), 500);
            }, 2000);
        }

        function showAchievement(title, description) {
            const achievement = document.createElement('div');
            achievement.className = 'achievement-popup';
            achievement.innerHTML = `
                <h3>üèÜ ${title}</h3>
                <p>${description}</p>
            `;
            document.body.appendChild(achievement);
            
            setTimeout(() => {
                achievement.style.opacity = '0';
                setTimeout(() => achievement.remove(), 500);
            }, 3000);
        }

        function triggerEnvironmentalEvent() {
            const events = [
                {
                    name: 'Toxin Storm',
                    execute: () => {
                        Environment.toxicity = Math.min(100, Environment.toxicity + 30);
                        document.getElementById('toxicitySlider').value = Environment.toxicity;
                        document.getElementById('toxicityValue').textContent = `${Environment.toxicity}%`;
                        showNotification('‚ö†Ô∏è Toxin Storm! Toxicity increased!', 'warning');
                        flashScreen();
                    }
                },
                {
                    name: 'Nutrient Surge',
                    execute: () => {
                        Environment.nutrientLevel = Math.min(2.0, Environment.nutrientLevel + 0.5);
                        document.getElementById('nutrientSlider').value = Environment.nutrientLevel * 100;
                        document.getElementById('nutrientValue').textContent = `${Math.floor(Environment.nutrientLevel * 100)}%`;
                        showNotification('‚ú® Nutrient Surge! Food abundance!', 'success');
                    }
                },
                {
                    name: 'Heat Wave',
                    execute: () => {
                        Environment.temperature = Math.min(100, Environment.temperature + 25);
                        document.getElementById('temperatureSlider').value = Environment.temperature;
                        document.getElementById('temperatureValue').textContent = `${Environment.temperature}¬∞C`;
                        showNotification('üî• Heat Wave! Temperature rising!', 'warning');
                        flashScreen();
                    }
                }
            ];
            
            const event = events[Math.floor(Math.random() * events.length)];
            event.execute();
        }

        function flashScreen() {
            const wrapper = document.getElementById('canvasWrapper');
            wrapper.classList.add('flash');
            setTimeout(() => wrapper.classList.remove('flash'), 300);
        }

        function shakeScreen() {
            const wrapper = document.getElementById('canvasWrapper');
            wrapper.classList.add('shake');
            setTimeout(() => wrapper.classList.remove('shake'), 500);
        }

        function updateLegend() {
            Object.values(CellTypes).forEach(type => {
                const legendItem = document.querySelector(`.legend-item[data-celltype="${type.name}"]`);
                if (legendItem) {
                    if (type.unlocked) {
                        legendItem.classList.remove('locked');
                        const lock = legendItem.querySelector('.lock-icon');
                        if (lock) lock.remove();
                    } else {
                        legendItem.classList.add('locked');
                    }
                }
            });
        }

        // Initialize
        function initialize() {
            cells = [new Cell(
                Math.floor(Config.gridWidth / 2),
                Math.floor(Config.gridHeight / 2),
                CellTypes.STEM,
                0
            )];
            
            spatialGrid = new SpatialGrid(Config.gridWidth, Config.gridHeight);

            totalDivisions = 0;
            time = 0;
            particles = [];
            updateStats();
            updatePhase();
            initializeChart();
            clearSelection();
            updateChallengeDisplay();
            transform = {
                scale: window.innerWidth < 768 ? 0.5 : 1,
                offsetX: 0,
                offsetY: 0
            };
        }

        // Update simulation
        function update() {
            if (!running) return;

            time++;

            if (time % 10 === 0) {
                recordPopulationHistory();
                updateChart();
            }

            // Random environmental events
            if (time % 300 === 0 && Math.random() < 0.3) {
                triggerEnvironmentalEvent();
            }

            // --- START: Spatial Grid Update (Fix for Bug 2) ---
            spatialGrid.clear();
            cells.forEach(cell => spatialGrid.add(cell));
            // --- END: Spatial Grid Update ---

            morphogenField.update(cells);
            cells = cells.filter(cell => cell.isAlive);
            cells.forEach(cell => cell.update(morphogenField));

            applyAdhesion(spatialGrid);
            updateNervousSystem(spatialGrid);

            const energyTransfers = [];
            cells.forEach(cell => {
                if (cell.type === CellTypes.DIGESTIVE) {
                    cell.energy = Math.min(100, cell.energy + 0.5);
                }
                getNeighborCoordinates(cell).forEach(({nx, ny}) => {
                    const neighbor = spatialGrid.get(nx, ny);
                    if (neighbor && neighbor.energy < cell.energy) {
                        const transfer = (cell.energy - neighbor.energy) * 0.01;
                        energyTransfers.push({ from: cell, to: neighbor, amount: transfer });
                    }
                });
            });

            energyTransfers.forEach(({ from, to, amount }) => {
                from.energy -= amount;
                to.energy += amount;
            });

            // --- REPLACED Division Logic (Fix for Bug 2 & 3) ---
            const newCells = [];
            const claimedSpots = new Set(); // Bug 3 fix: track new spots

            // Randomize cell order to prevent division bias
            const shuffledCells = cells
                .filter(cell => cell.readyToDivide && cells.length + newCells.length < 2000)
                .sort(() => Math.random() - 0.5);

            for (const cell of shuffledCells) {
                const directions = [
                    {dx: 1, dy: 0}, {dx: -1, dy: 0},
                    {dx: 0, dy: 1}, {dx: 0, dy: -1}
                ].sort(() => Math.random() - 0.5); // Randomize directions

                for (const dir of directions) {
                    const nx = cell.x + dir.dx;
                    const ny = cell.y + dir.dy;
                    const spotKey = `${nx},${ny}`; // Key for our claimed spots set

                    if (nx >= 0 && nx < Config.gridWidth && ny >= 0 && ny < Config.gridHeight) {
                        
                        // Bug 2 fix: O(1) check
                        const occupied = spatialGrid.get(nx, ny); 
                        
                        // Bug 3 fix: Check grid AND claimedSpots
                        if (!occupied && !claimedSpots.has(spotKey)) { 
                            const newCell = new Cell(nx, ny, CellTypes.STEM, cell.generation + 1);
                            newCells.push(newCell);
                            
                            claimedSpots.add(spotKey); // Claim this spot

                            cell.divisionCooldown = 30;
                            cell.readyToDivide = false;
                            totalDivisions++;
                            break; // Cell has divided, move to next cell
                        }
                    }
                }
            }

            cells.push(...newCells);
            // --- END of REPLACED Logic ---

            // Update particles
            particles = particles.filter(p => p.update());

            checkChallenges();
            draw();
            updateStats();
            updatePhase();

            requestAnimationFrame(update);
        }

        function getNeighborCoordinates(cell) {
            const coords = [];
            const directions = [{dx: 1, dy: 0}, {dx: -1, dy: 0}, {dx: 0, dy: 1}, {dx: 0, dy: -1}];
            for (const dir of directions) {
                coords.push({ nx: cell.x + dir.dx, ny: cell.y + dir.dy });
            }
            return coords;
        }

        function applyAdhesion(spatialGrid) { 
            if (Config.adhesionStrength === 0) return;

            const moves = [];

            for (const cell of cells) {
                // ...
                const currentNeighbors = getNeighborCoordinates(cell)
                    .filter(coord => spatialGrid.get(coord.nx, coord.ny)) 
                    .length;

                let bestSpot = null;
                let maxNeighbors = currentNeighbors;

                const emptyNeighbors = getNeighborCoordinates(cell)
                    .filter(coord => !spatialGrid.get(coord.nx, coord.ny) && 
                        coord.nx >= 0 && coord.nx < Config.gridWidth &&
                        coord.ny >= 0 && coord.ny < Config.gridHeight);

                for (const spot of emptyNeighbors) {
                    const potentialNeighbors = getNeighborCoordinates({ x: spot.nx, y: spot.ny })
                        .filter(coord => {
                            const isOccupied = spatialGrid.get(coord.nx, coord.ny); 
                            const isSelf = coord.nx === cell.x && coord.ny === cell.y;
                            return isOccupied && !isSelf;
                        }).length + 1;

                    if (potentialNeighbors > maxNeighbors) {
                        maxNeighbors = potentialNeighbors;
                        bestSpot = spot;
                    }
                }
                // ...
            }

            const occupiedTargets = new Set();
            for (const move of moves) {
                const targetKey = `${move.to.x},${move.to.y}`;
                if (!occupiedTargets.has(targetKey) && !spatialGrid.get(move.to.x, move.to.y)) { 
                    move.cell.x = move.to.x;
                    move.cell.y = move.to.y;
                    occupiedTargets.add(targetKey);
                }
            }
        }

        function updateNervousSystem(spatialGrid) { 
            const firingNeurons = new Set();
            // ... (stimulus logic) ...

            cells.forEach(cell => {
                // ... (cell logic) ...
            });

            firingNeurons.forEach(firingNeuron => {
                getNeighborCoordinates(firingNeuron).forEach(({ nx, ny }) => {
                    const neighbor = spatialGrid.get(nx, ny); 
                    if (!neighbor) return;

                    if (neighbor.type === CellTypes.NEURAL && neighbor.fireCooldown === 0) {
                        neighbor.voltage += 0.6;
                    }

                    if (neighbor.type === CellTypes.MUSCLE && neighbor.contractCooldown === 0) {
                        neighbor.isContracting = true;
                        neighbor.contractCooldown = 15;
                        neighbor.energy -= 5;
                    }
                });
            });
        }

        // Draw
        function draw() {
            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            ctx.translate(transform.offsetX, transform.offsetY);
            ctx.scale(transform.scale, transform.scale);

            if (viewMode === 'cells') {
                drawCells();
            } else if (viewMode === 'chemicals') {
                drawChemicals();
            } else if (viewMode === 'energy') {
                drawEnergy();
            } else if (viewMode === 'genes') {
                drawGeneActivity();
            }

            // Draw particles
            particles.forEach(p => p.draw(ctx));

            ctx.restore();
        }

        function drawCells() {
            cells.forEach(cell => {
                const x = cell.x * Config.cellSize;
                const y = cell.y * Config.cellSize;

                ctx.fillStyle = cell.type.color;
                ctx.beginPath();
                ctx.arc(x + Config.cellSize/2, y + Config.cellSize/2, Config.cellSize/2 - 1, 0, Math.PI * 2);
                ctx.fill();

                if (cell.isFiring || cell.isContracting) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.beginPath();
                    ctx.arc(x + Config.cellSize / 2, y + Config.cellSize / 2, Config.cellSize / 4, 0, Math.PI * 2);
                    ctx.fill();
                }

                if (cell.age < 10 || cell.justDifferentiated) {
                    ctx.shadowColor = cell.type.glow;
                    ctx.shadowBlur = 15;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    if (cell.justDifferentiated && cell.age > 5) {
                        cell.justDifferentiated = false;
                    }
                }
            });

            if (selectedCell && selectedCell.isAlive) {
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2 / transform.scale;
                ctx.beginPath();
                const radius = Config.cellSize / 2;
                ctx.arc(selectedCell.x * Config.cellSize + radius, selectedCell.y * Config.cellSize + radius, radius, 0, Math.PI * 2);
                ctx.stroke();
            }
        }

        function drawChemicals() {
            for (let y = 0; y < Config.gridHeight; y++) {
                for (let x = 0; x < Config.gridWidth; x++) {
                    const signals = morphogenField.getSignalsAt(x, y);
                    const intensity = signals.signalA * 255;

                    ctx.fillStyle = `rgba(79, 172, 254, ${intensity / 255 * 0.5})`;
                    ctx.fillRect(x * Config.cellSize, y * Config.cellSize, Config.cellSize, Config.cellSize);
                }
            }

            cells.forEach(cell => {
                const x = cell.x * Config.cellSize;
                const y = cell.y * Config.cellSize;

                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.beginPath();
                ctx.arc(x + Config.cellSize/2, y + Config.cellSize/2, Config.cellSize/3, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawEnergy() {
            cells.forEach(cell => {
                const x = cell.x * Config.cellSize;
                const y = cell.y * Config.cellSize;

                const normalizedEnergy = Math.min(cell.energy / 150, 1.0);
                const hue = 240 - (normalizedEnergy * 180);
                const lightness = 30 + (normalizedEnergy * 40);

                ctx.fillStyle = `hsl(${hue}, 100%, ${lightness}%)`;
                ctx.beginPath();
                ctx.arc(x + Config.cellSize / 2, y + Config.cellSize / 2, Config.cellSize / 2 - 1, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawGeneActivity() {
            cells.forEach(cell => {
                const x = cell.x * Config.cellSize;
                const y = cell.y * Config.cellSize;

                const activity = Math.min(cell.age / 50, 1);
                const r = Math.floor(activity * 255);
                const g = Math.floor((1 - activity) * 255);

                ctx.fillStyle = `rgb(${r}, ${g}, 100)`;
                ctx.fillRect(x, y, Config.cellSize, Config.cellSize);

                if (cell.readyToDivide) {
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x, y, Config.cellSize, Config.cellSize);
                }
            });
        }

        function updateStats() {
            const stats = getStatistics();
            document.getElementById('cellCount').textContent = stats.totalCells.toLocaleString();
            document.getElementById('stemCells').textContent = stats.stemCells.toLocaleString();
            document.getElementById('divisions').textContent = stats.totalDivisions.toLocaleString();
            document.getElementById('generation').textContent = stats.maxGeneration.toLocaleString();
        }

        function getStatistics() {
            const stats = {
                totalCells: cells.length,
                totalDivisions: totalDivisions,
                maxGeneration: cells.length > 0 ? Math.max(...cells.map(c => c.generation)) : 0
            };

            Object.values(CellTypes).forEach(type => {
                stats[`${type.name}Cells`] = 0;
            });

            cells.forEach(cell => {
                const typeName = cell.type.name;
                const key = `${typeName}Cells`;
                stats[key]++;
            });

            return stats;
        }

        function updatePhase() {
            let phase;
            if (cells.length === 1) {
                phase = 'SINGLE CELL';
            } else if (cells.length < 10) {
                phase = 'EARLY DIVISION';
            } else if (cells.length < 50) {
                phase = 'DIFFERENTIATION';
            } else if (cells.length < 200) {
                phase = 'MORPHOGENESIS';
            } else {
                phase = 'MATURE ORGANISM';
            }

            currentPhase = phase;
            document.getElementById('phaseIndicator').textContent = `Development: ${currentPhase}`;
        }

        function initializeChart() {
            const chartCanvas = document.getElementById('populationChart');
            if (populationChart) {
                populationChart.destroy();
            }

            populationHistory = [];

            const datasets = Object.values(CellTypes)
                .filter(type => type !== CellTypes.PREDATOR)
                .map(type => ({
                    label: type.name.charAt(0).toUpperCase() + type.name.slice(1),
                    data: [],
                    borderColor: type.color,
                    backgroundColor: type.glow,
                    fill: false,
                    borderWidth: 2,
                    pointRadius: 0,
                    tension: 0.4
                }));

            populationChart = new Chart(chartCanvas, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: {
                        duration: 200
                    },
                    scales: {
                        x: {
                            ticks: { color: '#a0c8ff' },
                            grid: { color: 'rgba(79, 172, 254, 0.1)' }
                        },
                        y: {
                            beginAtZero: true,
                            ticks: { color: '#a0c8ff' },
                            grid: { color: 'rgba(79, 172, 254, 0.2)' }
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: {
                                color: '#e0f0ff',
                                boxWidth: 12,
                                font: { size: 10 }
                            }
                        }
                    }
                }
            });
        }

        function recordPopulationHistory() {
            const stats = getStatistics();
            const historyPoint = { time: time };
            Object.values(CellTypes).forEach(type => {
                historyPoint[type.name] = stats[`${type.name}Cells`] || 0;
            });
            populationHistory.push(historyPoint);
            if (populationHistory.length > 100) {
                populationHistory.shift();
            }
        }

        function updateChart() {
            populationChart.data.labels = populationHistory.map(p => p.time);
            populationChart.data.datasets.forEach(dataset => {
                const typeName = dataset.label.toLowerCase();
                dataset.data = populationHistory.map(p => p[typeName]);
            });
            populationChart.update();
        }

        function clearSelection() {
            selectedCell = null;
            updateCellInfoPanel();
            draw();
        }

        function handleCanvasClick(e) {
            if (isPanning) return;
            
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            const worldX = (mouseX - transform.offsetX) / transform.scale;
            const worldY = (mouseY - transform.offsetY) / transform.scale;

            const gridX = Math.floor(worldX / Config.cellSize);
            const gridY = Math.floor(worldY / Config.cellSize);

            const clickedCell = cells.find(c => c.x === gridX && c.y === gridY);

            if (clickedCell) {
                selectedCell = clickedCell;
                updateCellInfoPanel();
                draw();
            }
        }

        function updateCellInfoPanel() {
            const panel = document.getElementById('cellInfoPanel');
            const clearBtn = document.getElementById('clearSelectionBtn');
            if (selectedCell && selectedCell.isAlive) {
                panel.style.display = 'block';
                clearBtn.style.display = 'block';
                document.getElementById('info-type').textContent = selectedCell.type.name.charAt(0).toUpperCase() + selectedCell.type.name.slice(1);
                document.getElementById('info-pos').textContent = `${selectedCell.x}, ${selectedCell.y}`;
                document.getElementById('info-age').textContent = selectedCell.age;
                document.getElementById('info-gen').textContent = selectedCell.generation;
                document.getElementById('info-energy').textContent = selectedCell.energy.toFixed(1);
                
                let status = 'Normal';
                if (selectedCell.readyToDivide) status = 'Ready to Divide';
                if (selectedCell.isFiring) status = 'Firing';
                if (selectedCell.isContracting) status = 'Contracting';
                if (selectedCell.type === CellTypes.PREDATOR) status = 'Hunting';
                document.getElementById('info-status').textContent = status;
            } else {
                panel.style.display = 'none';
                clearBtn.style.display = 'none';
            }
        }

        // Tutorial system
        let tutorialStep = 0;
        const tutorialSteps = [
            {
                title: 'Welcome to LifeForge! üß¨',
                text: 'LifeForge simulates how a single cell develops into a complex organism. Watch as cells divide, differentiate, and organize themselves!',
                highlight: null,
                action: null
            },
            {
                title: 'Starting Development',
                text: 'Click the "Start Development" button to begin the simulation. Your single cell will start dividing and growing.',
                highlight: '#startBtn',
                action: () => {
                    document.getElementById('startBtn').addEventListener('click', advanceTutorial, { once: true });
                }
            },
            {
                title: 'Watch the Canvas',
                text: 'The main canvas shows your developing organism. You can pan (drag) and zoom (scroll) to explore. Different colors represent different cell types.',
                highlight: '#canvasWrapper',
                action: null
            },
            {
                title: 'Cell Differentiation',
                text: 'Purple cells are stem cells. As they mature, they differentiate into specialized types: Neural (blue), Digestive (green), Muscle (red), and more!',
                highlight: '.cell-legend',
                action: null
            },
            {
                title: 'Environmental Controls',
                text: 'Adjust temperature, toxicity, and nutrients to see how your organism adapts. Too much toxicity can kill cells!',
                highlight: '#temperatureSlider',
                action: null
            },
            {
                title: 'Complete Challenges',
                text: 'Complete challenges to unlock new cell types and abilities. Try to reach 10 cells first!',
                highlight: '.challenge-panel',
                action: null
            },
            {
                title: "You're Ready!",
                text: 'Experiment with different settings, watch the chemical signals, and see how your organism evolves. Good luck, scientist!',
                highlight: null,
                action: null
            }
        ];

        function showTutorial() {
            tutorialStep = 0;
            displayTutorialStep();
        }

        function displayTutorialStep() {
            const step = tutorialSteps[tutorialStep];
            
            // Remove existing tutorial
            const existing = document.querySelector('.tutorial-overlay');
            if (existing) existing.remove();
            
            const existing2 = document.querySelector('.tutorial-highlight');
            if (existing2) existing2.remove();

            const overlay = document.createElement('div');
            overlay.className = 'tutorial-overlay';
            
            const box = document.createElement('div');
            box.className = 'tutorial-box';
            box.innerHTML = `
                <h2>${step.title}</h2>
                <p>${step.text}</p>
                <div class="tutorial-buttons">
                    ${tutorialStep > 0 ? '<button class="secondary" onclick="prevTutorial()">‚Üê Back</button>' : ''}
                    ${tutorialStep < tutorialSteps.length - 1 ? '<button onclick="advanceTutorial()">Next ‚Üí</button>' : '<button onclick="closeTutorial()">Start Exploring!</button>'}
                    <button class="secondary" onclick="closeTutorial()">Skip Tutorial</button>
                </div>
                <div style="margin-top: 15px; color: #64748b; font-size: 0.9rem;">
                    Step ${tutorialStep + 1} of ${tutorialSteps.length}
                </div>
            `;
            
            overlay.appendChild(box);
            document.body.appendChild(overlay);
            
            if (step.highlight) {
                const element = document.querySelector(step.highlight);
                if (element) {
                    const rect = element.getBoundingClientRect();
                    const highlight = document.createElement('div');
                    highlight.className = 'tutorial-highlight';
                    highlight.style.left = rect.left + 'px';
                    highlight.style.top = rect.top + 'px';
                    highlight.style.width = rect.width + 'px';
                    highlight.style.height = rect.height + 'px';
                    document.body.appendChild(highlight);
                }
            }
            
            if (step.action) {
                step.action();
            }
        }

        function advanceTutorial() {
            tutorialStep++;
            if (tutorialStep < tutorialSteps.length) {
                displayTutorialStep();
            } else {
                closeTutorial();
            }
        }

        function prevTutorial() {
            tutorialStep = Math.max(0, tutorialStep - 1);
            displayTutorialStep();
        }

        function closeTutorial() {
            const overlay = document.querySelector('.tutorial-overlay');
            const highlight = document.querySelector('.tutorial-highlight');
            if (overlay) overlay.remove();
            if (highlight) highlight.remove();
        }

        // Event listeners
        document.getElementById('startBtn').addEventListener('click', () => {
            if (!running) {
                running = true;
                update();
            }
        });

        document.getElementById('pauseBtn').addEventListener('click', () => {
            running = false;
        });

        document.getElementById('resetViewBtn').addEventListener('click', () => {
            transform = { scale: 1, offsetX: 0, offsetY: 0 };
            draw();
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            running = false;
            clearSelection();
            initialize();
            draw();
        });

        document.getElementById('clearSelectionBtn').addEventListener('click', () => {
            clearSelection();
        });

        document.getElementById('tutorialBtn').addEventListener('click', () => {
            showTutorial();
        });

        document.getElementById('speedSlider').addEventListener('input', function() {
            Config.speed = parseInt(this.value);
            document.getElementById('speedValue').textContent = this.value + 'x';
        });

        document.getElementById('mutationSlider').addEventListener('input', function() {
            Config.mutationRate = parseInt(this.value) / 100;
            document.getElementById('mutationValue').textContent = this.value + '%';
        });

        document.getElementById('divisionSlider').addEventListener('input', function() {
            Config.divisionRate = parseInt(this.value);
            document.getElementById('divisionValue').textContent = this.value;
        });

        document.getElementById('adhesionSlider').addEventListener('input', function() {
            Config.adhesionStrength = parseInt(this.value) / 100;
            document.getElementById('adhesionValue').textContent = this.value + '%';
        });

        document.getElementById('temperatureSlider').addEventListener('input', function() {
            Environment.temperature = parseInt(this.value);
            document.getElementById('temperatureValue').textContent = `${this.value}¬∞C`;
        });

        document.getElementById('toxicitySlider').addEventListener('input', function() {
            Environment.toxicity = parseInt(this.value);
            document.getElementById('toxicityValue').textContent = `${this.value}%`;
        });

        document.getElementById('nutrientSlider').addEventListener('input', function() {
            Environment.nutrientLevel = parseInt(this.value) / 100;
            document.getElementById('nutrientValue').textContent = `${this.value}%`;
        });

        document.getElementById('mutateBtn').addEventListener('click', () => {
            cells.forEach(cell => {
                if (Math.random() < 0.3) {
                    const availableTypes = Object.values(CellTypes).filter(t => t.unlocked && t !== CellTypes.STEM && t !== CellTypes.PREDATOR);
                    if (availableTypes.length > 0) {
                        cell.type = availableTypes[Math.floor(Math.random() * availableTypes.length)];
                        createParticleBurst(
                            cell.x * Config.cellSize + Config.cellSize/2,
                            cell.y * Config.cellSize + Config.cellSize/2,
                            cell.type.color,
                            10,
                            'sparkle'
                        );
                    }
                }
            });
            draw();
            shakeScreen();
        });

        document.getElementById('addCellsBtn').addEventListener('click', () => {
            for (let i = 0; i < 10; i++) {
                const x = Math.floor(Math.random() * Config.gridWidth);
                const y = Math.floor(Math.random() * Config.gridHeight);
                const occupied = cells.some(c => c.x === x && c.y === y);
                if (!occupied) {
                    cells.push(new Cell(x, y, CellTypes.STEM, 0));
                    createParticleBurst(
                        x * Config.cellSize + Config.cellSize/2,
                        y * Config.cellSize + Config.cellSize/2,
                        CellTypes.STEM.color,
                        8,
                        'burst'
                    );
                }
            }
            updateStats();
            draw();
            showNotification('Added 10 stem cells', 'success');
        });

        document.getElementById('killCellsBtn').addEventListener('click', () => {
            const toRemove = Math.floor(cells.length * 0.2);
            for (let i = 0; i < toRemove; i++) {
                const index = Math.floor(Math.random() * cells.length);
                if (cells[index]) {
                    createParticleBurst(
                        cells[index].x * Config.cellSize + Config.cellSize/2,
                        cells[index].y * Config.cellSize + Config.cellSize/2,
                        cells[index].type.color,
                        10,
                        'burst'
                    );
                    cells.splice(index, 1);
                }
            }
            updateStats();
            draw();
            shakeScreen();
            showNotification('Eliminated 20% of cells', 'warning');
        });

        document.getElementById('spawnPredatorBtn').addEventListener('click', () => {
            const x = Math.floor(Math.random() * Config.gridWidth);
            const y = Math.floor(Math.random() * Config.gridHeight);
            const predator = new Cell(x, y, CellTypes.PREDATOR, 0);
            predator.energy = 150;
            cells.push(predator);
            
            createParticleBurst(
                x * Config.cellSize + Config.cellSize/2,
                y * Config.cellSize + Config.cellSize/2,
                CellTypes.PREDATOR.color,
                20,
                'burst'
            );
            
            draw();
            shakeScreen();
            showNotification('‚ö†Ô∏è Predator spawned!', 'warning');
        });

        document.querySelectorAll('.view-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.view-btn').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                viewMode = this.dataset.view;
                draw();
            });
        });

        document.getElementById('exportImageBtn').addEventListener('click', () => {
            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = canvas.width;
            exportCanvas.height = canvas.height;
            const exportCtx = exportCanvas.getContext('2d');

            exportCtx.fillStyle = '#0a0e1a';
            exportCtx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);
            exportCtx.drawImage(canvas, 0, 0);

            exportCtx.fillStyle = '#4facfe';
            exportCtx.font = 'bold 20px Arial';
            exportCtx.fillText('LifeForge - Developmental Biology', 10, 30);

            exportCtx.fillStyle = '#a0c8ff';
            exportCtx.font = '14px Arial';
            exportCtx.fillText(`Cells: ${cells.length} | Phase: ${currentPhase}`, 10, 55);
            exportCtx.fillText(`Score: ${score} | Time: ${time}`, 10, 75);

            exportCanvas.toBlob(blob => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `lifeforge-${Date.now()}.png`;
                a.click();
                URL.revokeObjectURL(url);
            });
        });

        // Pan and zoom
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            const worldX = (mouseX - transform.offsetX) / transform.scale;
            const worldY = (mouseY - transform.offsetY) / transform.scale;

            const zoomFactor = 1.1;

            if (e.deltaY < 0) {
                transform.scale *= zoomFactor;
            } else {
                transform.scale /= zoomFactor;
            }
            transform.scale = Math.max(0.1, Math.min(transform.scale, 20));

            transform.offsetX = mouseX - worldX * transform.scale;
            transform.offsetY = mouseY - worldY * transform.scale;

            draw();
        });

        const startPan = (e) => {
            isPanning = true;
            lastMousePos.x = e.clientX || e.touches[0].clientX;
            lastMousePos.y = e.clientY || e.touches[0].clientY;
            canvas.style.cursor = 'grabbing';
        };

        const doPan = (e) => {
            if (!isPanning) return;
            const clientX = e.clientX || e.touches[0].clientX;
            const clientY = e.clientY || e.touches[0].clientY;

            const dx = clientX - lastMousePos.x;
            const dy = clientY - lastMousePos.y;

            transform.offsetX += dx;
            transform.offsetY += dy;

            lastMousePos.x = clientX;
            lastMousePos.y = clientY;

            draw();
        };

        const endPan = () => {
            isPanning = false;
            canvas.style.cursor = 'grab';
        };

        canvas.addEventListener('mousedown', startPan);
        canvas.addEventListener('mousemove', doPan);
        canvas.addEventListener('mouseup', endPan);
        canvas.addEventListener('mouseleave', endPan);

        canvas.addEventListener('touchstart', startPan, { passive: true });
        canvas.addEventListener('touchmove', doPan, { passive: true });
        canvas.addEventListener('touchend', endPan);

        canvas.addEventListener('click', handleCanvasClick);

        // Initialize
        window.addEventListener('load', () => {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            initialize();
            draw();
            
            // Auto-start tutorial for first-time users
            setTimeout(() => {
                if (localStorage.getItem('lifeforge_tutorial_shown') !== 'true') {
                    showTutorial();
                    localStorage.setItem('lifeforge_tutorial_shown', 'true');
                }
            }, 1000);
        });
    </script>
</body>
</html>
